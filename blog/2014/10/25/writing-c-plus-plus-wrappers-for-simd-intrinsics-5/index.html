
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Writing C++ Wrappers for SIMD Intrinsics (5) - The C++ scientist</title>
  <meta name="author" content="Johan Mabille">

  
  <meta name="description" content="4. Making the code more generic In the previous section we saw how to plug the wrappers into existing code and ended up with the following loop: &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jmabille.github.io/blog/2014/10/25/writing-c-plus-plus-wrappers-for-simd-intrinsics-5">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="The C++ scientist" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-55863412-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The C++ scientist</a></h1>
  
    <h2>Scientific computing, numerical methods and optimization in C++</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jmabille.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Writing C++ Wrappers for SIMD Intrinsics (5)</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-25T11:28:18+02:00" pubdate data-updated="true">Oct 25<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2 id="making-the-code-more-generic">4. Making the code more generic</h2>

<p>In the previous section we saw how to plug the wrappers into existing code and ended up with the following loop:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>sample.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
</pre></td>
  <td class="code"><pre>
std::vector&lt;<span class="predefined-type">float</span>&gt; a, b, c, d, e
<span class="comment">// Somewhere in the code the vectors are resized</span>
<span class="comment">// so they hold n elements</span>
<span class="keyword">for</span>(size_t i = <span class="integer">0</span>; i &lt; n/<span class="integer">4</span>; i+=<span class="integer">4</span>)
{
    vector4f av; av.load_a(&amp;a[i]);
    vector4f bv; bv.load_a(&amp;b[i]);
    vector4f cv; cv.load_a(&amp;c[i]);
    vector4f dv; dv.load_a(&amp;d[i]);

    vector4f ev = av*bv + cv*dv;
    ev.store_a(&amp;e[i]);
}
<span class="comment">// Remaining part of the loop</span>
<span class="comment">// ...</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<!-- more -->

<p>As said in the previous section, the first problem of this code is its lack of genericity; we are highly coupled with the
SIMD instruction set wrapped, and replacing it with another one requires code changes we should avoid. If we want to make
the code independant from the SIMD instruction set and the related wrapper, we need to hide the specifics of this instruction
set, that is, the vector type and its size (the number of scalars it holds).</p>

<h3 id="hiding-the-wrapper-type">4.1 Hiding the wrapper type</h3>

<p>We want to be able to select the right wrapper depending on the scalar type and the instruction set used. When talking about
selecting a type depending on another one, the first thing that comes to mind is type traits. Here our traits must contain the
wrapper type and its size associated with the scalar type used:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_traits.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
    <span class="keyword">struct</span> simd_traits
    {
        <span class="keyword">typedef</span> T type;
        <span class="directive">static</span> <span class="directive">const</span> size_t size = <span class="integer">1</span>;
    };
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>The general definition of the traits class allows us to write code that works even for types that don’t have related
wrappers (numerical types defined by another user for instance). Then we need to specialize these definitions for float
and double, depending on the considered instruction set. Assume we can detect the instruction set available on our system
and save this information in a macro (we’ll see how to do that in a later section). The specialization of the traits
class will look like:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd.hpp</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
</pre></td>
  <td class="code"><pre>
<span class="preprocessor">#ifdef</span> USE_SSE
<span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct</span> simd_traits&lt;<span class="predefined-type">float</span>&gt;
    {
        <span class="keyword">typedef</span> vector4f type;
        <span class="directive">static</span> <span class="directive">const</span> size_t size = <span class="integer">4</span>;
    };

<span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct</span> simd_traits&lt;<span class="predefined-type">double</span>&gt;
    {
        <span class="keyword">typedef</span> vector2d type;
        <span class="directive">static</span> <span class="directive">const</span> size_t size = <span class="integer">2</span>;
    };
<span class="preprocessor">#elif</span> USE_AVX
<span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct</span> simd_traits&lt;<span class="predefined-type">float</span>&gt;
    {
        <span class="keyword">typedef</span> vector8f type;
        <span class="directive">static</span> <span class="directive">const</span> size_t size = <span class="integer">8</span>;
    };

<span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct</span> simd_traits&lt;<span class="predefined-type">double</span>&gt;
    {
        <span class="keyword">typedef</span> vector4d type;
        <span class="directive">static</span> <span class="directive">const</span> size_t size = <span class="integer">4</span>;
    };
<span class="preprocessor">#endif</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Now we can adapt the loop so it doesn’t explicitly refer to the vector4f type:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>sample.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
</pre></td>
  <td class="code"><pre>
std::vector&lt;<span class="predefined-type">float</span>&gt; a,b,c,d,e;
<span class="comment">// ... resize a, b, c, d, and e so they hold n elements</span>
<span class="keyword">typedef</span> simd_traits&lt;<span class="predefined-type">float</span>&gt;::type vec_type;
size_t vec_size = simd_traits&lt;<span class="predefined-type">float</span>&gt;::size;
<span class="keyword">for</span>(size_t i = <span class="integer">0</span>; i &lt; n/vec_size; i += vec_size)
{
    vec_type av; av.load_a(&amp;a[i]);
    vec_type bv; bv.load_a(&amp;b[i]);
    vec_type cv; cv.load_a(&amp;c[i]);
    vec_type dv; dv.load_a(&amp;d[i]);

    vec_type ev = av*bv + cv*dv;
    ev.store_a(&amp;e[i]);
}
<span class="comment">// Remaining part of the loop</span>
<span class="comment">// ...</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>That’s it! If we need to compile this code on a system where AVX is available, we have nothing to do. The macro
USE_AVX will be defined, the specialization of simd_traits with vector8f as inner type will be instantiated,
and the loop will use the vector8f wrapper and the AVX intrinsics. However, there’s still a problem: we can
migrate to any SIMD instruction set for which a wrapper is available, but we can’t use types that don’t have
related wrappers. The simd_traits works fine even for user defined types, but the load and store functions are
available for wrappers only. We need to provide generic versions of these functions that work with any type.</p>

<h3 id="generic-load-an-store-functions">4.2 Generic load an store functions</h3>

<p>Actually, all we have to do is to provide two versions of these functions: one for types that don’t have related
wrappers, and one that works with wrappers. Template specialization can be of help here, but since partial
specialization is not possible for functions, let’s wrap them into a simd_functions_invoker class:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
</pre></td>
  <td class="code"><pre>
<span class="comment">// Common implementation for types that support vectorization</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>, <span class="keyword">class</span> <span class="class">V</span>&gt;
    <span class="keyword">struct</span> simd_functions_invoker
    {
        <span class="directive">inline</span> <span class="directive">static</span> V
        set1(<span class="directive">const</span> T&amp; a) { <span class="keyword">return</span> V(a); }

        <span class="directive">inline</span> <span class="directive">static</span> V
        load_a(<span class="directive">const</span> T* src) { V res; res.load_a(src); <span class="keyword">return</span> res; }

        <span class="directive">inline</span> <span class="directive">static</span> V
        load_u(<span class="directive">const</span> T* src) { V res; res.load_u(src); <span class="keyword">return</span> res; }

        <span class="directive">inline</span> <span class="directive">static</span> <span class="directive">void</span>
        store_a(T* dst, <span class="directive">const</span> V&amp; src) { src.store_a(dst); }

        <span class="directive">inline</span> <span class="directive">static</span> <span class="directive">void</span>
        store_u(T* dst, <span class="directive">const</span> V&amp; src) { src.store_u(dst); }
    };

<span class="comment">// Specialization for types that don't support vectorization</span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
    <span class="keyword">struct</span> simd_functions_invoker&lt;T,T&gt;
    {
        <span class="directive">inline</span> <span class="directive">static</span> T
        set1(<span class="directive">const</span> T&amp; a) { <span class="keyword">return</span> T(a); }

        <span class="directive">inline</span> <span class="directive">static</span> T
        load_a(<span class="directive">const</span> T* src) { <span class="keyword">return</span> *src; }

        <span class="directive">inline</span> <span class="directive">static</span> T
        load_u(<span class="directive">const</span> T* src) { <span class="keyword">return</span> *src; }

        <span class="directive">inline</span> <span class="directive">static</span> <span class="directive">void</span>
        store_a(T* dst, <span class="directive">const</span> T&amp; src) { *dst = src; }

        <span class="directive">inline</span> <span class="directive">static</span> <span class="directive">void</span>
        store_u(T* dst, <span class="directive">const</span> T&amp; src) { *dst = src; }
    };
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>We’ve added the set1 function so we can intialize wrappers and scalar type from a single value in an
uniform way. Calling the generic functions would look like:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>sample.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">typedef</span> simd_traits&lt;<span class="predefined-type">float</span>&gt;::simd_type vec_type;
vec_type va = simd_functions_invoker&lt;<span class="predefined-type">float</span>,vec_type&gt;::load_a(a);
</pre></td>
</tr></table>
 </figure></notextile></div>

<p><a name="simd_load"></a>That’s too much verbose. Let’s add façade functions that deduce template parameters for us:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
</pre></td>
  <td class="code"><pre>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt; <span class="directive">inline</span> <span class="keyword">typename</span> simd_traits&lt;T&gt;::type
set1(<span class="directive">const</span> T&amp; a)
{ <span class="keyword">return</span> simd_functions_invoker&lt;T,<span class="keyword">typename</span> simd_traits&lt;T&gt;::type&gt;::set1(a); }

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt; <span class="directive">inline</span> <span class="keyword">typename</span> simd_traits&lt;T&gt;::type
load_a(<span class="directive">const</span> T* src)
{ <span class="keyword">return</span> simd_functions_invoker&lt;T,<span class="keyword">typename</span> simd_traits&lt;T&gt;::type&gt;::load_a(src); }

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt; <span class="directive">inline</span> <span class="keyword">typename</span> simd_traits&lt;T&gt;::type
load_u(<span class="directive">const</span> T* src)
{ <span class="keyword">return</span> simd_functions_invoker&lt;T,<span class="keyword">typename</span> simd_traits&lt;T&gt;::type&gt;::load_u(src); }

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt; <span class="directive">inline</span> <span class="directive">void</span>
store_a(T* dst, <span class="directive">const</span> <span class="keyword">typename</span> simd_traits&lt;T&gt;::type&amp; src)
{ simd_functions_invoker&lt;T,<span class="keyword">typename</span> simd_traits&lt;T&gt;::type&gt;::store_a(dst,src); }

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt; <span class="directive">inline</span> <span class="directive">void</span>
store_u(T* dst, <span class="directive">const</span> <span class="keyword">typename</span> simd_traits&lt;T&gt;::type&amp; src)
{ simd_functions_invoker&lt;T,<span class="keyword">typename</span> simd_traits&lt;T&gt;::type&gt;::store_u(dst,src); }
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Now we can use these generic functions in the previous loop so it works with any type, even those
that don’t support vectorization:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>sample.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
</pre></td>
  <td class="code"><pre>
std::vector&lt;<span class="predefined-type">float</span>&gt; a,b,c,d,e;
<span class="comment">// ... resize a, b, c, d, and e so they hold n elements</span>
<span class="keyword">typedef</span> simd_traits&lt;<span class="predefined-type">float</span>&gt;::type vec_type;
size_t vec_size = simd_traits&lt;<span class="predefined-type">float</span>&gt;::size;
<span class="keyword">for</span>(size_t i = <span class="integer">0</span>; i &lt; n/vec_size; i += vec_size)
{
    vec_type av = load_a(&amp;a[i]);
    vec_type bv = load_a(&amp;b[i]);
    vec_type cv = load_a(&amp;c[i]);
    vec_type dv = load_a(&amp;d[i]);

    vec_type ev = av*bv + cv*dv;
    store_a(&amp;e[i],ev);
}
<span class="comment">// Remaining part of the loop</span>
<span class="comment">// ...</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Or, if you want to be more concise:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>sample.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre>
std::vector&lt;<span class="predefined-type">float</span>&gt; a,b,c,d,e;
<span class="comment">// ... resize a, b, c, d, and e so they hold n elements</span>
<span class="keyword">typedef</span> simd_traits&lt;<span class="predefined-type">float</span>&gt;::type vec_type;
size_t vec_size = simd_traits&lt;<span class="predefined-type">float</span>&gt;::size;
<span class="keyword">for</span>(size_t i = <span class="integer">0</span>; i &lt; n/vec_size; i += vec_size)
{
    vec_type ev = load_a(&amp;a[i])*load_a(&amp;b[i]) + load_a(&amp;c[i])*load_a(&amp;d[i]));
    store_a(&amp;e[i], ev);
}
<span class="comment">// Remaining part of the loop</span>
<span class="comment">// ...</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>We’ve reached our goal, we can use intrinsics almost like floats; in a real application code, it is likely
that you initialize the wrappers through load functions, then perform the computations and finally store the
results (like in the not concise version of the generic loop); thus the only difference between classical code
and code with SIMD wrappers is the initialization and storing of wrappers (and eventually the functions signatures
if you want to pass wrappers instead of scalars), the other parts should be exactly the same and the code remains
easy to read and to maintain.</p>

<h3 id="detecting-the-supported-instruction-set">4.3 Detecting the supported instruction set</h3>

<p><a name="detecting_instr_set"></a>Until now, we’ve assumed we were able to detect at compile time the available instruction sets.
Let’s see now how to achieve this. Compilers often provide preprocessor tokens depending on the available instruction sets, but
these tokens may vary from one compiler to another, so we have to standardize that. On most 64-bit compilers, the tokens look
like <strong>__SSE__</strong> or <strong>__SSE3__</strong>, on 32-bit systems, Microsoft compilers set the preprocessor token <strong>_M_IX86_FP</strong> to
1 for SSE (vectorization of float) and 2 for SSE2 (vetorization of double and integers).</p>

<p>Here is how we can standardize that:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_config.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
</pre></td>
  <td class="code"><pre>
<span class="preprocessor">#if</span> (defined(_M_AMD64) || defined(_M_X64) || defined(__amd64)) &amp;&amp; ! defined(__x86_64__)
    <span class="preprocessor">#define</span> __x86_64__ <span class="integer">1</span>
<span class="preprocessor">#endif</span>

<span class="comment">// Find sse instruction set from compiler macros if SSE_INSTR_SET not defined</span>
<span class="comment">// Note: Not all compilers define these macros automatically</span>
<span class="preprocessor">#ifndef</span> SSE_INSTR_SET
    <span class="preprocessor">#if</span> defined ( __AVX2__ )
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">8</span>
    <span class="preprocessor">#elif</span> defined ( __AVX__ )
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">7</span>
    <span class="preprocessor">#elif</span> defined ( __SSE4_2__ )
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">6</span>
    <span class="preprocessor">#elif</span> defined ( __SSE4_1__ )
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">5</span>
    <span class="preprocessor">#elif</span> defined ( __SSSE3__ )
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">4</span>
    <span class="preprocessor">#elif</span> defined ( __SSE3__ )
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">3</span>
    <span class="preprocessor">#elif</span> defined ( __SSE2__ ) || defined ( __x86_64__ )
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">2</span>
    <span class="preprocessor">#elif</span> defined ( __SSE__ )
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">1</span>
    <span class="preprocessor">#elif</span> defined ( _M_IX86_FP )           <span class="comment">// Defined in MS compiler on 32bits system. 1: SSE, 2: SSE2</span>
        <span class="preprocessor">#define</span> SSE_INSTR_SET _M_IX86_FP
    <span class="preprocessor">#else</span>
        <span class="preprocessor">#define</span> SSE_INSTR_SET <span class="integer">0</span>
    <span class="preprocessor">#endif</span> <span class="comment">// instruction set defines</span>
<span class="preprocessor">#endif</span> <span class="comment">// SSE_INSTR_SET</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Now we can use the <strong>SSE_INSTR_SET</strong> token to include the right file:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_config.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
</pre></td>
  <td class="code"><pre>
<span class="preprocessor">#</span><span class="comment">// Include the appropriate header file for intrinsic functions</span>
<span class="preprocessor">#if</span> SSE_INSTR_SET &gt; <span class="integer">7</span>                  <span class="comment">// AVX2 and later</span>
    <span class="preprocessor">#ifdef</span> __GNUC__
        <span class="preprocessor">#include</span> <span class="include">&lt;x86intrin.h&gt;</span>         <span class="comment">// x86intrin.h includes header files for whatever instruction</span>
                                       <span class="comment">// sets are specified on the compiler command line, such as:</span>
                                       <span class="comment">// xopintrin.h, fma4intrin.h</span>
    <span class="preprocessor">#else</span>
        <span class="preprocessor">#include</span> <span class="include">&lt;immintrin.h&gt;</span>         <span class="comment">// MS version of immintrin.h covers AVX, AVX2 and FMA3</span>
    <span class="preprocessor">#endif</span> <span class="comment">// __GNUC__</span>
<span class="preprocessor">#elif</span> SSE_INSTR_SET == <span class="integer">7</span>
    <span class="preprocessor">#include</span> <span class="include">&lt;immintrin.h&gt;</span>             <span class="comment">// AVX</span>
<span class="preprocessor">#elif</span> SSE_INSTR_SET == <span class="integer">6</span>
    <span class="preprocessor">#include</span> <span class="include">&lt;nmmintrin.h&gt;</span>             <span class="comment">// SSE4.2</span>
<span class="preprocessor">#elif</span> SSE_INSTR_SET == <span class="integer">5</span>
    <span class="preprocessor">#include</span> <span class="include">&lt;smmintrin.h&gt;</span>             <span class="comment">// SSE4.1</span>
<span class="preprocessor">#elif</span> SSE_INSTR_SET == <span class="integer">4</span>
    <span class="preprocessor">#include</span> <span class="include">&lt;tmmintrin.h&gt;</span>             <span class="comment">// SSSE3</span>
<span class="preprocessor">#elif</span> SSE_INSTR_SET == <span class="integer">3</span>
    <span class="preprocessor">#include</span> <span class="include">&lt;pmmintrin.h&gt;</span>             <span class="comment">// SSE3</span>
<span class="preprocessor">#elif</span> SSE_INSTR_SET == <span class="integer">2</span>
    <span class="preprocessor">#include</span> <span class="include">&lt;emmintrin.h&gt;</span>             <span class="comment">// SSE2</span>
<span class="preprocessor">#elif</span> SSE_INSTR_SET == <span class="integer">1</span>
    <span class="preprocessor">#include</span> <span class="include">&lt;xmmintrin.h&gt;</span>             <span class="comment">// SSE</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Note that if you split the implementation of SSE wrappers and AVX wrappers into different files, you
can also use the <strong>SSE_INSTR_SET</strong> token to include the implementation file in the simd.hpp file:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre>
<span class="preprocessor">#include</span> <span class="include">&quot;simd_config.hpp&quot;</span>
<span class="preprocessor">#if</span> SSE_INSTR_SET &gt; <span class="integer">6</span>
    <span class="preprocessor">#include</span> <span class="include">&quot;simd_avx.hpp&quot;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#if</span> SSE_INSTR_SET &gt; <span class="integer">0</span>
    <span class="preprocessor">#include</span> <span class="include">&quot;simd_sse.hpp&quot;</span>
<span class="preprocessor">#endif</span>

<span class="comment">// Definition of traits and generic load and store functions</span>
<span class="comment">// ...</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Now from the client code, the only file to include is simd.hpp, and everything will be available.</p>

<h3 id="going-further">4.4 Going further</h3>

<p>Now that we have nice wrappers providing basic functionalities, what could be the next step ?
Well, first we could add a method to retrieve an element in the vector:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_base.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="keyword">class</span> <span class="class">simd_vector</span>
    {
    <span class="directive">public</span>:

        <span class="keyword">typedef</span> simd_traits&lt;X&gt;::value_type value_type;

        <span class="comment">// ...</span>

        value_type <span class="directive">operator</span>[](size_t index) <span class="directive">const</span>
        {
            size_t size = simd_traits&lt;X&gt;::size;
            value_type v[size];
            (*<span class="local-variable">this</span>)().store_u(v);
            <span class="keyword">return</span> v[index];
        }
    };
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>We can add horizontal add function, useful for linear algebra products:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre>
    <span class="directive">inline</span> <span class="predefined-type">float</span> hadd(<span class="directive">const</span> vector4f&amp; rhs)
    {
    <span class="preprocessor">#if</span> SSE_INSTR_SET &gt;= <span class="integer">3</span> <span class="comment">// SSE3</span>
        __m128 tmp0 = _mm_hadd_ps(rhs,rhs);
        __m128 tmp1 = _mm_hadd_ps(tmp0,tmp0);
    <span class="preprocessor">#else</span>
        __m128 tmp0 = _mm_add_ps(rhs,_mm_movehl_ps(rhs,rhs));
        __m128 tmp1 = _mm_add_ss(tmp0,_mm_shuffle_ps(tmp0,tmp0,<span class="integer">1</span>));
    <span class="preprocessor">#endif</span>
        <span class="keyword">return</span> _mm_cvtss_f32(tmp1);
    }
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Another useful project would be to write overloads of standard mathematical functions (exp, log, etc) that work
with the wrappers.</p>

<p>As you can see, writing the wrappers is just the beginning, you can then enrich them with whatever functionality
you need but this goes beyond the topic of this first series of articles.</p>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Johan Mabille</span></span>

      








  


<time datetime="2014-10-25T11:28:18+02:00" pubdate data-updated="true">Oct 25<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/simd/'>SIMD</a>, <a class='category' href='/blog/categories/vectorization/'>Vectorization</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/10/13/writing-c-plus-plus-wrappers-for-simd-intrinsics-4/" title="Previous Post: Writing C++ wrappers for SIMD intrinsics (4)">&laquo; Writing C++ wrappers for SIMD intrinsics (4)</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/11/20/performance-considerations-about-simd-wrappers/" title="Next Post: Performance considerations about SIMD wrappers">Performance considerations about SIMD wrappers &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/06/aligned-memory-allocator/">Aligned Memory Allocator</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/20/performance-considerations-about-simd-wrappers/">Performance Considerations About SIMD Wrappers</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/25/writing-c-plus-plus-wrappers-for-simd-intrinsics-5/">Writing C++ Wrappers for SIMD Intrinsics (5)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/13/writing-c-plus-plus-wrappers-for-simd-intrinsics-4/">Writing C++ Wrappers for SIMD Intrinsics (4)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-3/">Writing C++ Wrappers for SIMD Intrinsics (3)</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/jmabille">@jmabille</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jmabille',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Johan Mabille -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'thecplusplusscientist';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://jmabille.github.io/blog/2014/10/25/writing-c-plus-plus-wrappers-for-simd-intrinsics-5/';
        var disqus_url = 'http://jmabille.github.io/blog/2014/10/25/writing-c-plus-plus-wrappers-for-simd-intrinsics-5/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
