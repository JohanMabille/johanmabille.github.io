
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Writing C++ Wrappers for SIMD Intrinsics (3) - The C++ scientist</title>
  <meta name="author" content="Johan Mabille">

  
  <meta name="description" content="2. First version of wrappers Now that we know a little more about SSE and AVX, let’s start writing code; the wrappers will have
a data vector member &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jmabille.github.io/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="The C++ scientist" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The C++ scientist</a></h1>
  
    <h2>Scientific computing, numerical methods and optimization in C++</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jmabille.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Writing C++ Wrappers for SIMD Intrinsics (3)</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-10T02:35:03+02:00" pubdate data-updated="true">Oct 10<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2 id="a-namesection2a2-first-version-of-wrappers"><a name="section_2"></a>2. First version of wrappers</h2>

<p>Now that we know a little more about SSE and AVX, let’s start writing code; the wrappers will have
a data vector member and provide arithmetic, comparison and logical operators overloads. Through this
section, I will mainly focus on vector4f, the wrapper around __m128, but translating the code for
other data vectors should not be difficult thanks to the previous section. Since the wrappers will be
used as numerical types, they must have value semantics, that is they must define copy constructor,
assignment operator and non-virtual destructor.</p>

<!-- more -->

<h3 id="initialization-and-assignment">2.1 Initialization and assignment</h3>

<p>SSE and AVX data vectors can be initialized from different inputs : a single value for all elements,
a value per element, or another data vector.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">class</span> <span class="class">vector4f</span>
{
<span class="directive">public</span>:

    <span class="directive">inline</span> vector4f() {}
    <span class="directive">inline</span> vector4f(<span class="predefined-type">float</span> f) : m_value(_mm_set1_ps(f)) {}
    <span class="directive">inline</span> vector4f(<span class="predefined-type">float</span> f0, <span class="predefined-type">float</span> f1, <span class="predefined-type">float</span> f2, <span class="predefined-type">float</span> f3) : m_value(_mm_setr_ps(f0,f1,f2,f3)) {}
    <span class="directive">inline</span> vector4f(<span class="directive">const</span> __m128&amp; rhs) : m_value(rhs) {}

    <span class="directive">inline</span> vector4f&amp; <span class="directive">operator</span>=(<span class="directive">const</span> __m128&amp; rhs)
    {
        m_value = rhs;
        <span class="keyword">return</span> *<span class="local-variable">this</span>;
    }

    <span class="directive">inline</span> vector4f(<span class="directive">const</span> vector4f&amp; rhs) : m_value(rhs.m_value) {}

    <span class="directive">inline</span> vector4f&amp; <span class="directive">operator</span>=(<span class="directive">const</span> vector4f&amp; rhs)
    {
        m_value = rhs.m_value;
        <span class="keyword">return</span> *<span class="local-variable">this</span>;
    }

<span class="directive">private</span>:

    __m128 m_value;
};
</pre></td>
</tr></table>
 </figure></notextile></div>

<h3 id="implicit-conversion">2.2 Implicit conversion</h3>

<p>The operators overloads have to access the m_value member of the wrapper so they can pass it as an argument to the intrinsic
functions :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>overload sample</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
</pre></td>
  <td class="code"><pre>
vector4f <span class="directive">operator</span>+(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_add_ps(lhs.m_value,rhs.m_value);
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>We could declare the operator overloads as friend functions of the wrapper class, or provide a get method returning the internal
m_value. Both of these solutions work, but aren’t elegant : the first requires a huge amount of friend declaration, the second
produces heavy code unpleasant to read.</p>

<p>A more elegant solution is to provide a conversion operator from vector4f to __m128 ; since vector4f can be implicitly converted
from __m128, we can now use vector4f or __m128 indifferently. Moreover we can save the vector4f copy constructor and assignment
operator :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">class</span> <span class="class">vector4f</span>
{
<span class="directive">public</span>:

    <span class="directive">inline</span> vector4f() {}
    <span class="directive">inline</span> vector4f(<span class="predefined-type">float</span> f) : m_value(_mm_set1_ps(f)) {}
    <span class="directive">inline</span> vector4f(<span class="predefined-type">float</span> f0, <span class="predefined-type">float</span> f1, <span class="predefined-type">float</span> f2, <span class="predefined-type">float</span> f3) : m_value(_mm_setr_ps(f0,f1,f2,f3)) {}
    <span class="directive">inline</span> vector4f(<span class="directive">const</span> __m128&amp; rhs) : m_value(rhs) {}

    <span class="directive">inline</span> vector4f&amp; <span class="directive">operator</span>=(<span class="directive">const</span> __m128&amp; rhs)
    {
        m_value = rhs;
        <span class="keyword">return</span> *<span class="local-variable">this</span>;
    }

    <span class="directive">inline</span> <span class="directive">operator</span> __m128() <span class="directive">const</span> { <span class="keyword">return</span> m_value; }

    <span class="comment">// vector4f(const vector4f&amp;) and operator=(const vector4f&amp;) are not required anymore :</span>
    <span class="comment">// the conversion operator will be called before calling vector4f(const __m128&amp;)</span>
    <span class="comment">// or operator=(const __m128&amp;)</span>

<span class="directive">private</span>:

    __m128 m_value;
};
</pre></td>
</tr></table>
 </figure></notextile></div>

<h3 id="arithmetic-operators-overloads">2.3 Arithmetic operators overloads</h3>

<p>Next step is to write the arithmetic operators overloads. The classic way to do this is to write
computed assignment operators and to use them in operator overloads, so they don’t have to access
private members of vector4f ; but since vector4f can be implicitly converted to __m128, we can
do the opposite and avoid using a temporary (this won’t have any impact on performance since
the compiler can optimize it, but produces shorter and more pleasant code to read) :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">class</span> <span class="class">vector4f</span>
{
<span class="directive">public</span>:

    <span class="comment">// ...</span>

    <span class="directive">inline</span> vector4f&amp; <span class="directive">operator</span>+=(<span class="directive">const</span> vector4f&amp; rhs)
    {
        *<span class="local-variable">this</span> = *<span class="local-variable">this</span> + rhs;
        <span class="keyword">return</span> *<span class="local-variable">this</span>;
    }
};

<span class="directive">inline</span> vector4f <span class="directive">operator</span>+(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_add_ps(lhs,rhs);
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<h3 id="the-need-for-a-base-class">2.4 The need for a base class</h3>

<p>We could go ahead and write the remaining arithmetic operators overloads, just as we did before :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
</pre></td>
  <td class="code"><pre>
vector4f <span class="directive">operator</span>+(<span class="directive">const</span> vector4f&amp;, <span class="directive">const</span> vector4f&amp;);
<span class="comment">// Adds the same float value to each data vector member</span>
vector4f <span class="directive">operator</span>+(<span class="directive">const</span> vector4f&amp;, <span class="directive">const</span> <span class="predefined-type">float</span>&amp;);
vector4f <span class="directive">operator</span>+(<span class="directive">const</span> <span class="predefined-type">float</span>&amp;, <span class="directive">const</span> vector4f&amp;);

<span class="comment">// Similar for operator-, operator* and operator/</span>
<span class="comment">// ...</span>

vector4f <span class="directive">operator</span>-(<span class="directive">const</span> vector4f&amp;);

vector4f&amp; <span class="directive">operator</span>++();
vector4f <span class="directive">operator</span>++(<span class="predefined-type">int</span>);

<span class="comment">// Similar for operator--</span>
<span class="comment">// ...</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>But wait! Whenever you add a new wrapper, you’ll have to write these operators overloads again. Besides
the fact you’ll type a lot of boilerplate code, computed assignment operators will be the same as those
of vector4f (that is, invoke the corresponding operator overload and return the object), and even some
operators overloads will have the same code as the one of vector4f operators. Code duplication is never
good, and we should look for ways to avoid it.</p>

<p>If we had encountered this problem for classes with entity semantics, we would have captured the common code
into a base class, and delegate the specific behavior to virtual methods, a typical use of classical dynamic
polymorphism. What we need here is an equivalent architecture for classes with value semantics and no virtual
methods (since virtual assignment operators are nonsense). This equivalent architecture is the CRTP
(Curiously Recurring Template Pattern). A lot has been written about CRTP and I will not dwell on it. If you
don’t know about this pattern, the most important thing to know is CRTP allows you to invoke methods of inherite
classes from the base class just as you would do through virtual methods, except the target method is resolved
at compile time.</p>

<p>Let’s call our base class simd_vector, it will be used as base class for every wrapper ; here is what it should
look like :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_base.hpp</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
<a href="#n57" name="n57">57</a>
<a href="#n58" name="n58">58</a>
<a href="#n59" name="n59">59</a>
<strong><a href="#n60" name="n60">60</a></strong>
<a href="#n61" name="n61">61</a>
<a href="#n62" name="n62">62</a>
<a href="#n63" name="n63">63</a>
<a href="#n64" name="n64">64</a>
<a href="#n65" name="n65">65</a>
<a href="#n66" name="n66">66</a>
<a href="#n67" name="n67">67</a>
<a href="#n68" name="n68">68</a>
<a href="#n69" name="n69">69</a>
<strong><a href="#n70" name="n70">70</a></strong>
<a href="#n71" name="n71">71</a>
<a href="#n72" name="n72">72</a>
<a href="#n73" name="n73">73</a>
<a href="#n74" name="n74">74</a>
<a href="#n75" name="n75">75</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="keyword">struct</span> simd_vector_traits;

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="keyword">class</span> <span class="class">simd_vector</span>
    {
    <span class="directive">public</span>:

        <span class="keyword">typedef</span> <span class="keyword">typename</span> simd_vector_traits&lt;X&gt;::value_type value_type;

        <span class="comment">// downcast operators so we can call inherited methods</span>
        <span class="directive">inline</span> X&amp; <span class="directive">operator</span>()() { <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;X*&gt;(<span class="local-variable">this</span>); }
        <span class="directive">inline</span> <span class="directive">const</span> X&amp; <span class="directive">operator</span>()() <span class="directive">const</span> { <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;<span class="directive">const</span> X*&gt;(<span class="local-variable">this</span>); }

        <span class="comment">// Additional assignment operators</span>
        <span class="directive">inline</span> X&amp; <span class="directive">operator</span>+=(<span class="directive">const</span> X&amp; rhs)
        {
            (*<span class="local-variable">this</span>)() = (*<span class="local-variable">this</span>)() + rhs;
            <span class="keyword">return</span> (*<span class="local-variable">this</span>)();
        }

        <span class="directive">inline</span> X&amp; <span class="directive">operator</span>+=(<span class="directive">const</span> value_type&amp; rhs)
        {
            (*<span class="local-variable">this</span>)() = (*<span class="local-variable">this</span>)() + X(rhs);
            <span class="keyword">return</span> (*<span class="local-variable">this</span>)();
        }

        <span class="comment">// Same for operator-=, operator*=, operator/= ...</span>
        <span class="comment">// ...</span>

        <span class="comment">// Increment operators</span>
        <span class="directive">inline</span> X <span class="directive">operator</span>++(<span class="predefined-type">int</span>)
        {
            X tmp = (*<span class="local-variable">this</span>)();
            (*<span class="local-variable">this</span>) += value_type(<span class="integer">1</span>);
            <span class="keyword">return</span> tmp;
        }

        <span class="directive">inline</span> X&amp; <span class="directive">operator</span>++()
        {
            (*<span class="local-variable">this</span>)() += value_type(<span class="integer">1</span>);
            <span class="keyword">return</span> (*<span class="local-variable">this</span>)();
        }

        <span class="comment">// Similar decrement operators</span>
        <span class="comment">// ...</span>

    <span class="directive">protected</span>:

        <span class="comment">// Ensure only inheriting classes can instantiate / copy / assign simd_vector.</span>
        <span class="comment">// Avoids incomplete copy / assignment from client code.</span>
        <span class="directive">inline</span> simd_vector() {}
        <span class="directive">inline</span> ~simd_vector() {}

        <span class="directive">inline</span> simd_vector(<span class="directive">const</span> simd_vector&amp;) {}
        <span class="directive">inline</span> simd_vector&amp; <span class="directive">operator</span>=(<span class="directive">const</span>  simd_vector&amp;) { <span class="keyword">return</span> *<span class="local-variable">this</span>; }
    };

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="directive">inline</span> simd_vector&lt;X&gt; <span class="directive">operator</span>+(<span class="directive">const</span> simd_vector&lt;X&gt;&amp; lhs,
                                    <span class="directive">const</span> <span class="keyword">typename</span> simd_vector_traits&lt;X&gt;::type&amp; rhs)
    {
        <span class="keyword">return</span> lhs() + X(rhs);
    }

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="directive">inline</span> simd_vector&lt;X&gt; <span class="directive">operator</span>+(<span class="directive">const</span> <span class="keyword">typename</span> simd_vector_traits&lt;X&gt;::type&amp; lhs,
                                    <span class="directive">const</span> simd_vector&lt;X&gt;&amp; rhs)
    {
        <span class="keyword">return</span> X(lhs) + rhs();
    }

<span class="comment">// Same for operator-, operator*, operator/</span>
<span class="comment">// ...</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Now, all vector4f needs to do is to inherit from simd_vector and implement the traditional operator+, and
it will get operator+= and the operator+ overloads for free (and the same for other arithmetic operators) :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">class</span> <span class="class">vector4f</span> : <span class="directive">public</span> simd_vector&lt;vector4f&gt;
{
<span class="directive">public</span>:

    <span class="directive">inline</span> vector4f() {}
    <span class="directive">inline</span> vector4f(<span class="predefined-type">float</span> f) : m_value(_mm_set1_ps(f)) {}
    <span class="directive">inline</span> vector4f(<span class="predefined-type">float</span> f0, <span class="predefined-type">float</span> f1, <span class="predefined-type">float</span> f2, <span class="predefined-type">float</span> f3) : m_value(_mm_setr_ps(f0,f1,f2,f3)) {}
    <span class="directive">inline</span> vector4f(<span class="directive">const</span> __m128&amp; rhs) : m_value(rhs) {}

    <span class="directive">inline</span> vector4f&amp; <span class="directive">operator</span>=(<span class="directive">const</span> __m128&amp; rhs)
    {
        m_value = rhs;
        <span class="keyword">return</span> *<span class="local-variable">this</span>;
    }

    <span class="directive">inline</span> <span class="directive">operator</span> __m128() <span class="directive">const</span> { <span class="keyword">return</span> m_value; }

    <span class="comment">// No more operator+= since it is implemented in the base class</span>

<span class="directive">private</span>:

    __m128 m_value;
};

<span class="comment">// Base on this operator implementation, simd_vector&lt;vector4f&gt; will generate</span>
<span class="comment">// the following methods and overloads :</span>
<span class="comment">// vector4f&amp; operator+=(const vector4f&amp;)</span>
<span class="comment">// vector4f operator++(int)</span>
<span class="comment">// vector4f&amp; operator++()</span>
<span class="comment">// vector4f operator+(const vector4f&amp;, ocnst float&amp;)</span>
<span class="comment">// vector4f operator+(const float&amp;, const vector4f&amp;)</span>
<span class="directive">inline</span> vector4f <span class="directive">operator</span>+(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_add_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4f <span class="directive">operator</span>-(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_sub_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4f <span class="directive">operator</span>*(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_mul_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4f <span class="directive">operator</span>/(<span class="directive">const</span> vetcor4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_div_ps(lhs,rhs);
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Looks good, doesn’t it ? Every time we want to implement a new wrapper, we only have to code 4 operators and
make our class inherit from simd_vector, and all overloads will be generated for free!</p>

<p>Just one remark before we continue with comparison operators ; if you have noticed, the base class simd_vector
defines a type named value_type, depending on the nature of the inheriting class (float for vector4f, double
for vector2d, …). However, this type is not defined by the inheriting class, but by a traits class instead.
This is a CRTP constraint : you can access the inheriting class as long the compiler doesn’t instantiate the
code; if you call a method defined in the inheriting class, the compiler will assume it exists until it has to
instantiate the code. But type resolution is different and you have to define it out of the inheriting class.
This is one reason for the existence of the simd_vector_traits class. Other reasons will be discussed in a later
section. Note the class containing the type definition doesn’t have to be fully defined at this point : a simple
forward declaration is sufficient.</p>

<h3 id="comparison-operators">2.5 Comparison operators</h3>

<p>Since ordinary comparison operators return boolean value, we need to implement SIMD wrappers for boolean. The
number of boolean elements of the wrappers will be directly related to the number of floating values wrapped
by our arithmetic wrappers.</p>

<p>In order not to duplicate code, we’ll use the same architecture as for arithmetic wrappers : a CRTP with
base class for common code, and inheriting classes for specific implementation. Here is the implementation
of the simd_vector_bool class, the base used to generate bitwise assignment operators and logical operators
overloads in inheriting classes :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_base.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
<a href="#n57" name="n57">57</a>
<a href="#n58" name="n58">58</a>
<a href="#n59" name="n59">59</a>
<strong><a href="#n60" name="n60">60</a></strong>
<a href="#n61" name="n61">61</a>
<a href="#n62" name="n62">62</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="keyword">class</span> <span class="class">simd_vector_bool</span>
    {
    <span class="directive">public</span>:

        <span class="directive">inline</span> X&amp; <span class="directive">operator</span>()() { <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;X*&gt;(<span class="local-variable">this</span>); }
        <span class="directive">inline</span> <span class="directive">const</span> X&amp; <span class="directive">operator</span>()() <span class="directive">const</span> { <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;<span class="directive">const</span> X*&gt;(<span class="local-variable">this</span>); }

        <span class="directive">inline</span> X&amp; <span class="directive">operator</span>&amp;=(<span class="directive">const</span> X&amp; rhs)
        {
            (*<span class="local-variable">this</span>) = (*<span class="local-variable">this</span>) &amp;&amp; rhs;
            <span class="keyword">return</span> (*<span class="local-variable">this</span>)();
        }

        <span class="directive">inline</span> X&amp; <span class="directive">operator</span>|(<span class="directive">const</span> X&amp; rhs)
        {
            (*<span class="local-variable">this</span>)() = (*<span class="local-variable">this</span>) || rhs;
            <span class="keyword">return</span> (*<span class="local-variable">this</span>)();
        }

        <span class="directive">inline</span> X&amp; <span class="directive">operator</span>^=(<span class="directive">const</span> X&amp; rhs)
        {
            (*<span class="local-variable">this</span>)() = (*<span class="local-variable">this</span>)() ^ rhs;
            <span class="keyword">return</span> (*<span class="local-variable">this</span>)();
        }

    <span class="directive">protected</span>:

        <span class="directive">inline</span> simd_vector_bool() {}
        <span class="directive">inline</span> ~simd_vector_bool() {}

        <span class="directive">inline</span> simd_vector_bool(<span class="directive">const</span> simd_vector_bool&amp;) {}
        <span class="directive">inline</span> simd_vector_bool&amp; <span class="directive">operator</span>=(<span class="directive">const</span> simd_vector_bool&amp;) { <span class="keyword">return</span> *<span class="local-variable">this</span>; }
    };

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="directive">inline</span> X <span class="directive">operator</span>&amp;&amp;(<span class="directive">const</span> simd_vector_bool&lt;X&gt;&amp; lhs, <span class="directive">const</span> simd_vector_bool&lt;X&gt;&amp; rhs)
    {
        <span class="keyword">return</span> lhs() &amp; rhs();
    }

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="directive">inline</span> X <span class="directive">operator</span>&amp;&amp;(<span class="directive">const</span> simd_vector_bool&lt;X&gt;&amp; lhs, <span class="predefined-type">bool</span> rhs)
    {
        <span class="keyword">return</span> lhs() &amp; rhs;
    }

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="directive">inline</span> X <span class="directive">operator</span>||(<span class="predefined-type">bool</span> lhs, <span class="directive">const</span> simd_vector_bool&lt;X&gt;&amp; rhs)
    {
        <span class="keyword">return</span> lhs &amp; rhs();
    }

<span class="comment">// Similar for operator|| overloads</span>
<span class="comment">// ...</span>

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="directive">inline</span> X <span class="directive">operator</span>!(<span class="directive">const</span> simd_vector_bool&lt;X&gt;&amp; rhs)
    {
        <span class="keyword">return</span> rhs() == <span class="integer">0</span>;
    }
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>The inheriting class vector4fb only has to provide bitwise operators and equality/inequality operators :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">class</span> <span class="class">vector4fb</span> : <span class="directive">public</span> simd_vector_bool&lt;vector4fb&gt;
{
<span class="directive">public</span>:

    <span class="directive">inline</span> vector4fb() {}
    <span class="directive">inline</span> vector4fb(<span class="predefined-type">bool</span> b) : m_value(_mm_castsi128_ps(_mm_set1_epi32(-(<span class="predefined-type">int</span>)b))) {}
    <span class="directive">inline</span> vector4fb(<span class="predefined-type">bool</span> b0, <span class="predefined-type">bool</span> b1, <span class="predefined-type">bool</span> b2, <span class="predefined-type">bool</span> b3)
    : m_value(_mm_castsi128_ps(_mm_setr_epi32(-(<span class="predefined-type">int</span>)b0,-(<span class="predefined-type">int</span>)b1,-(<span class="predefined-type">int</span>)b2,-(<span class="predefined-type">int</span>)b3))) {}

    <span class="directive">inline</span> vector4fb(<span class="directive">const</span> __m128&amp; rhs) : m_value(rhs) {}

    <span class="directive">inline</span> vector4fb&amp; <span class="directive">operator</span>=(<span class="directive">const</span> __m128&amp; rhs)
    {
        m_value = rhs;
        <span class="keyword">return</span> *<span class="local-variable">this</span>;
    }

    <span class="directive">inline</span> <span class="directive">operator</span> __m128() <span class="directive">const</span> { <span class="keyword">return</span> m_value; }

<span class="directive">private</span>:

    __m128 m_value;
};

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>&amp;(<span class="directive">const</span> vector4fb&amp; lhs, <span class="directive">const</span> vector4fb&amp; rhs)
{
    <span class="keyword">return</span> _mm_and_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>|(<span class="directive">const</span> vector4fb&amp; lhs, <span class="directive">const</span> vector4fb&amp; rhs)
{
    <span class="keyword">return</span> _mm_or_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>^(<span class="directive">const</span> vector4fb&amp; lhs, <span class="directive">const</span> vector4fb&amp; rhs)
{
    <span class="keyword">return</span> _mm_xor_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>~(<span class="directive">const</span> vector4fb&amp; rhs)
{
    <span class="keyword">return</span> _mm_xor_ps(rhs,_mm_castsi128_ps(_mm_set1_epi32(-<span class="integer">1</span>)));
}

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>==(<span class="directive">const</span> vector4fb&amp; lhs, <span class="directive">const</span> vector4fb&amp; rhs)
{
    <span class="keyword">return</span> _mm_cmeq_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>!=(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4fb&amp; rhs)
{
    <span class="keyword">return</span> _mm_cmpneq_ps(lhs,rhs);
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Now we have wrappers for boolean, we can add the comparison operators to the vector4f class; again,
to avoid code duplication, some operators will be implemented in the base class and will be based on
specific operators implemented in the inheriting class. Let’s start with the vector4f comparison
operators :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
</pre></td>
  <td class="code"><pre>
<span class="comment">// Definition of vector4f and arithmetic overloads</span>
<span class="comment">// ...</span>
<span class="directive">inline</span> vector4fb <span class="directive">operator</span>==(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_cmpeq_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>!=(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_cmpneq_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>&lt;(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_cmplt_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4fb <span class="directive">operator</span>&lt;=(<span class="directive">const</span> vector4f&amp; lhs, <span class="directive">const</span> vector4f&amp; rhs)
{
    <span class="keyword">return</span> _mm_cmple_ps(lhs,rhs);
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Before we implement operator&gt; and operator&gt;= for the base class, we have to focus on their return
type. If these operators were implemented for vector4f, we would have return vector4fb; but since
they are implemented for the base class, they need to return the boolean wrapper related to the
arithmetic wrapper, i.e the inheriting class. What we need here is to provide a mapping between
arithmetic wrapper type and boolean wrapper type somewhere. Remeber the simd_vector_traits structure
we declared to define our value_type ? It would be the perfect place for defining that mapping :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
</pre></td>
  <td class="code"><pre>
<span class="comment">// simd_vector_traits&lt;vector4f&gt; must be defined before vector4f so simd_vector can compile</span>
<span class="comment">// (remember we use simd_vector_traits&lt;X&gt;::value_type in the definition of simd_vector).</span>
<span class="keyword">class</span> <span class="class">vector4f</span>;

<span class="comment">// Full specialization of the template vector_simd_traits declared in simd_base.hpp</span>
<span class="keyword">template</span> &lt;&gt;
    <span class="keyword">struct</span> vector_simd_traits&lt;vector4f&gt;
    {
        <span class="keyword">typedef</span> <span class="predefined-type">float</span> value_type;
        <span class="keyword">typedef</span> simd_vector4fb vetor_bool;
    };

<span class="keyword">class</span> <span class="class">vector4f</span>
{
    <span class="comment">// ...</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>A last remark before we add the last comparison operators : since the template vector_simd_traits
will never be defined but full specialized instead, there is no risk we forget to define it when
we add a new wrapper, we’ll have a compilation error.</p>

<p>Finally, we can add the missing operators for the base class :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_base.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
</pre></td>
  <td class="code"><pre>
<span class="comment">// Declaration of simd_vector and operators</span>
<span class="comment">//...</span>

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="directive">inline</span> <span class="keyword">typename</span> simd_vector_traits&lt;X&gt;::vector_bool
    <span class="directive">operator</span>&gt;(<span class="directive">const</span> simd_vector&lt;X&gt;&amp; lhs, <span class="directive">const</span> simd_vector&lt;X&gt;&amp; rhs)
    {
        <span class="keyword">return</span> rhs() &lt;= lhs();
    }

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">X</span>&gt;
    <span class="directive">inline</span> <span class="keyword">typename</span> simd_vector_traits&lt;X&gt;::vector_bool
    <span class="directive">operator</span>&gt;=(<span class="directive">const</span> simd_vector&lt;X&gt;&amp; lhs, <span class="directive">const</span> simd_vector&lt;X&gt;&amp; rhs)
    {
        <span class="keyword">return</span> rhs() &lt; lhs();
    }
</pre></td>
</tr></table>
 </figure></notextile></div>

<h3 id="logical-operators">2.6 Logical operators</h3>

<p>Since float provides logical operators, our wrapper should do so. The implementation is the same
as for the simd_vector_bool class, that is logical assignment operator in the simd_vector base class,
and operator overloads for the inheriting classes. The implementation of operator|, operator&amp;, operator^
and operaotr~ is the same as the one for vector4fb, so I don’t repeat it here.</p>

<h3 id="next-step">2.7 Next step</h3>

<p>Next step is to implement wrapper for 2 double, then wrapper for 8 float and 4 double if you want to support
AVX. You can also implement wrappers for int if you aim to do integre computation. The implementation is
similar to what has been done in this section.</p>

<p>Now we have nice wrappers, we’ll see in the next section how to plug them on existing code.</p>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Johan Mabille</span></span>

      








  


<time datetime="2014-10-10T02:35:03+02:00" pubdate data-updated="true">Oct 10<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/simd/'>SIMD</a>, <a class='category' href='/blog/categories/vectorization/'>Vectorization</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-2/" title="Previous Post: Writing C++ Wrappers for SIMD Intrinsics (2)">&laquo; Writing C++ Wrappers for SIMD Intrinsics (2)</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-3/">Writing C++ Wrappers for SIMD Intrinsics (3)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-2/">Writing C++ Wrappers for SIMD Intrinsics (2)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/09/writing-c-plus-plus-wrappers-for-simd-intrinsics-1/">Writing C++ Wrappers for SIMD Intrinsics (1)</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/jmabille">@jmabille</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jmabille',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Johan Mabille -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
