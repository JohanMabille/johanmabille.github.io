
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Performance Considerations Aboud SIMD Wrappers - The C++ scientist</title>
  <meta name="author" content="Johan Mabille">

  
  <meta name="description" content="When I posted a link to this blog on reddit,
I had comments from people who were skeptical of the SIMD Wrappers
performances. They raised many &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jmabille.github.io/blog/2014/11/20/performance-considerations-aboud-simd-wrappers">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="The C++ scientist" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-55863412-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The C++ scientist</a></h1>
  
    <h2>Scientific computing, numerical methods and optimization in C++</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jmabille.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Performance Considerations Aboud SIMD Wrappers</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-20T01:39:57+01:00" pubdate data-updated="true">Nov 20<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>When I posted a link to this blog on <a href="http://www.reddit.com/r/cpp/comments/2laltn/ths_c_scientist_blog_is_born/">reddit</a>,
I had comments from people who were skeptical of the <a href="http://jmabille.github.io/blog/2014/10/09/writing-c-plus-plus-wrappers-for-simd-intrinsics-1/">SIMD Wrappers</a>
performances. They raised many possible performance hits in the implementation:</p>

<ul>
  <li>Arguments passed by const references instead of values, introducing a useless indirection and preventing the compiler from
keeping the variable into registers</li>
  <li>Indirection due to the wrapping of __mXXX types into objects</li>
  <li>Operator overloads preventing the compiler from proper instructions reordering during optimization</li>
</ul>

<!-- more -->

<p>I’ve always thought the compiler was smart enough to handle registers and optimizations, whatever the type of the functions arguments (const
references or values); and I don’t understand why operators overloads shouldn’t be considered as classical functions by the compiler. But well,
maybe I am too optimistic about the capabilities of the compiler? I was suggested a solution based on pure functions that should be simpler
and faster, but I was not given any evidence. Let’s take a closer look at both implementations and the assembly code they generate so we can say
whether or not the wrappers introduce performance hits.</p>

<p>Before we go further, here are some technical details: the compiler used in this article is gcc 4.7.3, results may be different with another compiler
(and I am interested in seeing these results). The SIMD wrappers used are those of the article series mentioned above, and the implementation based
on stateless pure functions looks like:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_function.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">typedef</span> __m128 vector4f2;

<span class="directive">inline</span> vector4f2 add(vector4f2 lhs, vector4f2 rhs)
{
    <span class="keyword">return</span> _mm_add_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4f mul(vector4f2 lhs, vector4f2 rhs)
{
    <span class="keyword">return</span> _mm_mul_ps(lhs,rhs);
}

<span class="directive">inline</span> vector4f2 load_a(<span class="directive">const</span> <span class="predefined-type">float</span>* src)
{
    <span class="keyword">return</span> _mm_load_ps(src);
}

<span class="directive">inline</span> vector4f2 store_a(<span class="predefined-type">float</span>* dst, vector4f2 src)
{
    _mm_store_ps(dst,src);
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<h2 id="pure-function-vs-simd-wrappers">1. Pure function vs SIMD wrappers</h2>

<p>Let’s see the assembly code generated by the following functions:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre>
vector4f test_sse_a(vector4f a, vector4f b)
{
    <span class="keyword">return</span> a + b;
}


vector4f2 test_sse_a2(vector4f2 a, vector4f2 b)
{
    <span class="keyword">return</span> add(a,b);
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>The generated assembly code is:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test.asm </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre>
// test_sse_a
   0:    c5 f8 28 06              vmovaps (%rsi),%xmm0
   4:    48 89 f8                 mov    %rdi,%rax
   7:    c5 f8 58 02              vaddps (%rdx),%xmm0,%xmm0
   b:    c5 f8 29 07              vmovaps %xmm0,(%rdi)
   f:    c3                       retq
// test_sse_a2
   0:    c5 f8 58 c1              vaddps %xmm1,%xmm0,%xmm0
   4:    c3                       retq
   5:    66 66 2e 0f 1f 84 00     data32 nopw %cs:0x0(%rax,%rax,1)
   c:    00 00 00 00 
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>If you’re not familiar with assembler, vaddps is the assembly for _mm_add_ps (strictly speaking for _m256_add_ps, but this doesn’t make a 
big difference), vmovaps is a transfer instruction from memory to SIMD register (load) or from SIM register to memory (store) depending on its
arguments, and %xmmX are the SIMD registers. Do not worry about the last line of the test_sse_a2 function, this is a “do-nothing” operation,
used for padding, and does not concern us here.</p>

<p>So what can we tell at first sight ? Well, it seems SIMD wrappers introduce an overhead, using transfer instructions, while the implementation
based on stateless functions directly uses register. Now the question is why. Is this due to constant reference arguments ?</p>

<h2 id="constant-reference-argument-vs-value-argument">2. Constant reference argument vs value argument</h2>

<p>If we change the code of the SIMD wrappers operator overloads to take their arguments by value rather than by constant reference, the generated
assembly code doesn’t change:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre>
<span class="directive">inline</span> vector4f <span class="directive">operator</span>+(vector4f lhs, vector4f rhs)
{
    <span class="keyword">return</span> _mm_add_ps(lhs,rhs);
}

<span class="comment">// test_sse_a asm:</span>
   <span class="integer">0</span>:    c5 f8 <span class="integer">28</span> <span class="octal">06</span>              vmovaps (%rsi),%xmm0
   <span class="integer">4</span>:    <span class="integer">48</span> <span class="integer">89</span> f8                 mov    %rdi,%rax
   <span class="integer">7</span>:    c5 f8 <span class="integer">58</span> <span class="octal">02</span>              vaddps (%rdx),%xmm0,%xmm0
   b:    c5 f8 <span class="integer">29</span> <span class="octal">07</span>              vmovaps %xmm0,(%rdi)
   f:    c3
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Moreover, if we change the functional implementation so it takes arguments by constant reference instead of value, the generated assembly code for
test_sse_a2 is exactly the same as in the previous section:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre>
<span class="directive">inline</span> vector4f2 add(<span class="directive">const</span> vector4f2&amp; lhs, <span class="directive">const</span> vector4f2&amp; rhs)
{
    <span class="keyword">return</span> _mm_add_ps(lhs,rhs);
}

<span class="comment">// test_sse_a2 asm:</span>
   <span class="integer">0</span>:    c5 f8 <span class="integer">58</span> c1              vaddps %xmm1,%xmm0,%xmm0
   <span class="integer">4</span>:    c3                       retq
   <span class="integer">5</span>:    <span class="integer">66</span> <span class="integer">66</span> <span class="float">2</span>e <span class="float">0f</span> <span class="float">1f</span> <span class="integer">84</span> <span class="octal">00</span>     data32 nopw %cs:<span class="hex">0x0</span>(%rax,%rax,<span class="integer">1</span>)
   c:    <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span> 
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>As I supposed, the compiler (at least gcc) is smart enough to optimize and keep in register arguments passed by constant reference (if they fit into
registers of course). So it seems the overhead comes from the indirection of the wrapping, but this is really hard to believe.</p>

<h2 id="and-the-culprit-is-">3. And the culprit is …</h2>

<p>To confirm this hypothesis, let’s simplify the code of the wrapper so we only test the indirection. Inheritance from the <strong>simd_vector</strong> base class
is removed:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
</pre></td>
  <td class="code"><pre>
<span class="keyword">class</span> <span class="class">vector4f</span>
{
<span class="directive">public</span>:

    <span class="directive">inline</span> vector4f2() {}
    <span class="directive">inline</span> vector4f2(__m128 rhs) : m_value(rhs) {}

    <span class="directive">inline</span> vector4f2&amp; <span class="directive">operator</span>=(__m128 rhs)
        {
            m_value = rhs;
            <span class="keyword">return</span> *<span class="local-variable">this</span>;
        }

    <span class="directive">inline</span> <span class="directive">operator</span> __m128() <span class="directive">const</span> { <span class="keyword">return</span> m_value; }

<span class="directive">private</span>:

        __m128 m_value;
};

<span class="directive">inline</span> vector4f2 <span class="directive">operator</span>+(vector4f2 lhs, vector4f2 rhs) { <span class="keyword">return</span> _mm_add_ps(lhs,rhs); }
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Now if we dump the assembly code of the test_sse_add function we defined in the beginning, here is what we get:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre>
<span class="comment">// test_sse_a asm:</span>
   <span class="integer">0</span>:    c5 f8 <span class="integer">58</span> c1              vaddps %xmm1,%xmm0,%xmm0
   <span class="integer">4</span>:    c3                       retq   
   <span class="integer">5</span>:    <span class="integer">66</span> <span class="integer">66</span> <span class="float">2</span>e <span class="float">0f</span> <span class="float">1f</span> <span class="integer">84</span> <span class="octal">00</span>     data32 nopw %cs:<span class="hex">0x0</span>(%rax,%rax,<span class="integer">1</span>)
   c:    <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span> 
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>That’s exactly the same code as the one generated by pure stateless functions. So the indirection of the wrapper doesn’t introduce any
overhead. Since the only change we’ve made from the previous wrapper is to remove the CRTP layer, we have the culprit for the overhead
we noticed in the beginning: the CRTP layer.</p>

<p>I first thought of a Empty Base Optimization problem, but priting the size of both implementations of the wrapper proved me wrong: in both
case, the size of the wrapper is 16, so it fits in the XMM registers. So I must admit, I still have no explanation for this problem.</p>

<p>In the next section, I will consider the wrapper implementation that doesn’t use CRTP. Now that we’ve fixed this issue, let’s
see if operators overload prevents the compiler from proper instructions reordering during optimization.</p>

<h2 id="operators-overload">4. Operators overload</h2>

<p>For this test, I use the following functions:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test2.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
</pre></td>
  <td class="code"><pre>
vector4f2 test_sse_b2(vector4f2 a, vector4f2 b, vector4f2 c, vector4f2 d)
{
    <span class="keyword">return</span> add(mul(a,b),mul(c,d));
}

vector4f2 test_sse_c2(vector4f2 a, vector4f2 b, vector4f2 c, vector4f2 d)
{
    <span class="keyword">return</span> add(add(mul(a,b),div(c,d)),sub(div(c,b),mul(a,d)));
}

vector4f2 test_sse_d2(vector4f2 a, vector4f2 b, vector4f2 c, vector4f2 d)
{
    <span class="keyword">return</span> mul(test_sse_c2(a,b,c,d),test_sse_b2(a,b,c,d));
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>And the equivalent functions for wrappers:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
</pre></td>
  <td class="code"><pre>
vector4f test_sse_b(vector4f a, vector4f b, vector4f c, vector4f d)
{
    <span class="keyword">return</span> a*b + c*d;
}

vector4f test_sse_c(vector4f a, vector4f b, vector4f c, vector4f d)
{
    <span class="keyword">return</span> (a*b + c/d) + (c/b - a*d);
}

vector4f test_sse_d(vector4f a, vector4f b, vector4f c, vector4f d)
{
    <span class="keyword">return</span> test_sse_c(a,b,c,d) * test_sse_b(a,b,c,d);
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Here the parenthesis in <strong>test_sse_c</strong> ensure the compiler generates the same syntactic tree for both implementations; indeed, if we omitted the brackets, the code would have been almost equivalent to:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test2_bis.cpp</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre>
<span class="comment">// same code for test_sse_b2 and test_sse_d2</span>

vector4f2 test_sse_c2(vector4f2 a, vector4f2 b, vector4f2 c, vector4f2 d)
{
    <span class="keyword">return</span> sub(add(div(c,b),add(mul(a,b),div(c,d))),mul(a,d));
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Here is the generated assembly code with explanations in comments:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test.asm </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
</pre></td>
  <td class="code"><pre>
<span class="comment">// test_sse_d</span>
  <span class="integer">40</span>:    c5 f8 <span class="integer">59</span> e1              vmulps %xmm1,%xmm0,%xmm4 <span class="comment">// a*b in xmm4</span>
  <span class="integer">44</span>:    c5 e8 <span class="float">5</span>e c9              vdivps %xmm1,%xmm2,%xmm1 <span class="comment">// c/b in xmm1</span>
  <span class="integer">48</span>:    c5 f8 <span class="integer">59</span> c3              vmulps %xmm3,%xmm0,%xmm0 <span class="comment">// a*d in xmm0</span>
  <span class="integer">4</span>c:    c5 e8 <span class="integer">59</span> eb              vmulps %xmm3,%xmm2,%xmm5 <span class="comment">// c*d in xmm5</span>
  <span class="integer">50</span>:    c5 d8 <span class="integer">58</span> ed              vaddps %xmm5,%xmm4,%xmm5 <span class="comment">// a*b + c*d in xmm5</span>
  <span class="integer">54</span>:    c5 f0 <span class="integer">5</span>c c8              vsubps %xmm0,%xmm1,%xmm1 <span class="comment">// c/b - a*d in xmm1</span>
  <span class="integer">58</span>:    c5 e8 <span class="float">5</span>e c3              vdivps %xmm3,%xmm2,%xmm0 <span class="comment">// c/d in xmm0</span>
  <span class="integer">5</span>c:    c5 d8 <span class="integer">58</span> c0              vaddps %xmm0,%xmm4,%xmm0 <span class="comment">// a*b + c/d in xmm0</span>
  <span class="integer">60</span>:    c5 f8 <span class="integer">58</span> c1              vaddps %xmm1,%xmm0,%xmm0 <span class="comment">// a*b + c/d + c/b - a*d in xmm0</span>
  <span class="integer">64</span>:    c5 f8 <span class="integer">59</span> c5              vmulps %xmm5,%xmm0,%xmm0 <span class="comment">// (a*b + c*d) * xmm0 in xmm0</span>
  <span class="integer">68</span>:    c3                       retq
  <span class="integer">69</span>:    <span class="float">0f</span> <span class="float">1f</span> <span class="integer">80</span> <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span>     nopl   <span class="hex">0x0</span>(%rax)

<span class="comment">// test_sse_d2</span>
  <span class="integer">40</span>:    c5 f8 <span class="integer">59</span> e1              vmulps %xmm1,%xmm0,%xmm4
  <span class="integer">44</span>:    c5 e8 <span class="float">5</span>e c9              vdivps %xmm1,%xmm2,%xmm1
  <span class="integer">48</span>:    c5 f8 <span class="integer">59</span> c3              vmulps %xmm3,%xmm0,%xmm0
  <span class="integer">4</span>c:    c5 e8 <span class="integer">59</span> eb              vmulps %xmm3,%xmm2,%xmm5
  <span class="integer">50</span>:    c5 d8 <span class="integer">58</span> ed              vaddps %xmm5,%xmm4,%xmm5
  <span class="integer">54</span>:    c5 f0 <span class="integer">5</span>c c8              vsubps %xmm0,%xmm1,%xmm1
  <span class="integer">58</span>:    c5 e8 <span class="float">5</span>e c3              vdivps %xmm3,%xmm2,%xmm0
  <span class="integer">5</span>c:    c5 d8 <span class="integer">58</span> c0              vaddps %xmm0,%xmm4,%xmm0
  <span class="integer">60</span>:    c5 f8 <span class="integer">58</span> c1              vaddps %xmm1,%xmm0,%xmm0
  <span class="integer">64</span>:    c5 f8 <span class="integer">59</span> c5              vmulps %xmm5,%xmm0,%xmm0
  <span class="integer">68</span>:    c3                       retq
  <span class="integer">69</span>:    <span class="float">0f</span> <span class="float">1f</span> <span class="integer">80</span> <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span>     nopl   <span class="hex">0x0</span>(%rax)
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>The generated assembly codes for <strong>test_sse_d</strong> and <strong>test_sse_d2</strong> are exactly the sames. Operators overloads and equivalent stateless functions generally produces the same assembly code provided that the syntax tree is the same in both implementations. Indeed, the evaluation order of operators arguments and functions arguments may differ, making it impossible to have the same syntax tree in both implementations when using non-commutative operators.</p>

<p>Now what if we mix computation instructions with loop, load and store ? Consider the following piece of code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test.cpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
</pre></td>
  <td class="code"><pre>
<span class="directive">void</span> test_sse_e(<span class="directive">const</span> std::vector&lt;<span class="predefined-type">float</span>&gt;&amp; a,
                <span class="directive">const</span> std::vector&lt;<span class="predefined-type">float</span>&gt;&amp; b,
                <span class="directive">const</span> std::vector&lt;<span class="predefined-type">float</span>&gt;&amp; c,
                <span class="directive">const</span> std::vector&lt;<span class="predefined-type">float</span>&gt;&amp; d,
                std::vector&lt;<span class="predefined-type">float</span>&gt;&amp; e)
{
    <span class="comment">// typedef vector4f2 for test_sse_e2 implementation</span>
    <span class="keyword">typedef</span> vector4f vec_type;
    size_t bound = a.size()/<span class="integer">4</span>;
    <span class="keyword">for</span>(size_t i = <span class="integer">0</span>; i &lt; bound; i += <span class="integer">4</span>)
    {
        vec_type av = load_a2(&amp;a[i]);
        vec_type bv = load_a2(&amp;b[i]);
        vec_type cv = load_a2(&amp;c[i]);
        vec_type dv = load_a2(&amp;d[i]);

    <span class="comment">// vec_type ev = test_sse_d2(av,bv,cv,dv); for test_sse_e2 implementation</span>
        vec_type ev = test_sse_d(av,bv,cv,dv);
        store_a(&amp;e[i],ev);
    }
}
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>Again, the generated assembly code is the same for both implementations:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_test.asm</span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
<a href="#n57" name="n57">57</a>
<a href="#n58" name="n58">58</a>
<a href="#n59" name="n59">59</a>
<strong><a href="#n60" name="n60">60</a></strong>
<a href="#n61" name="n61">61</a>
<a href="#n62" name="n62">62</a>
<a href="#n63" name="n63">63</a>
<a href="#n64" name="n64">64</a>
<a href="#n65" name="n65">65</a>
<a href="#n66" name="n66">66</a>
<a href="#n67" name="n67">67</a>
<a href="#n68" name="n68">68</a>
</pre></td>
  <td class="code"><pre>
<span class="comment">// test_sse_e:</span>
  <span class="integer">70</span>:    <span class="integer">4</span>c <span class="integer">8</span>b <span class="float">0f</span>                 mov    (%rdi),%r9
  <span class="integer">73</span>:    <span class="integer">48</span> <span class="integer">8</span>b <span class="float">7f</span> <span class="integer">08</span>              mov    <span class="hex">0x8</span>(%rdi),%rdi
  <span class="integer">77</span>:    <span class="integer">4</span>c <span class="integer">29</span> cf                 sub    %r9,%rdi
  <span class="integer">7</span>a:    <span class="integer">48</span> c1 ff <span class="octal">02</span>              sar    $<span class="hex">0x2</span>,%rdi
  <span class="float">7</span>e:    <span class="integer">48</span> c1 ef <span class="octal">02</span>              shr    $<span class="hex">0x2</span>,%rdi
  <span class="integer">82</span>:    <span class="integer">48</span> <span class="integer">85</span> ff                 test   %rdi,%rdi
  <span class="integer">85</span>:    <span class="integer">74</span> <span class="integer">5</span>d                    je     e4 &lt;_ZN4simd11test_sse_eERKSt6vectorIfSaIfEES4_S4_S4_RS2_+<span class="hex">0x74</span>&gt;
  <span class="integer">87</span>:    <span class="integer">4</span>c <span class="integer">8</span>b <span class="integer">16</span>                 mov    (%rsi),%r10
  <span class="integer">8</span>a:    <span class="integer">31</span> c0                    <span class="keyword">xor</span>    %eax,%eax
  <span class="integer">8</span>c:    <span class="integer">48</span> <span class="integer">8</span>b <span class="integer">32</span>                 mov    (%rdx),%rsi
  <span class="float">8f</span>:    <span class="integer">48</span> <span class="integer">8</span>b <span class="integer">09</span>                 mov    (%rcx),%rcx
  <span class="integer">92</span>:    <span class="integer">49</span> <span class="integer">8</span>b <span class="integer">10</span>                 mov    (%r8),%rdx
  <span class="integer">95</span>:    <span class="float">0f</span> <span class="float">1f</span> <span class="octal">00</span>                 nopl   (%rax)
  <span class="integer">98</span>:    c5 f8 <span class="integer">28</span> <span class="integer">0</span>c <span class="integer">86</span>           vmovaps (%rsi,%rax,<span class="integer">4</span>),%xmm1
  <span class="integer">9</span>d:    c5 f8 <span class="integer">28</span> <span class="octal">04</span> <span class="integer">81</span>           vmovaps (%rcx,%rax,<span class="integer">4</span>),%xmm0
  a2:    c4 c1 <span class="integer">78</span> <span class="integer">28</span> <span class="integer">24</span> <span class="integer">81</span>        vmovaps (%r9,%rax,<span class="integer">4</span>),%xmm4
  a8:    c4 c1 <span class="integer">78</span> <span class="integer">28</span> <span class="integer">1</span>c <span class="integer">82</span>        vmovaps (%r10,%rax,<span class="integer">4</span>),%xmm3
  ae:    c5 f0 <span class="integer">59</span> e8              vmulps %xmm0,%xmm1,%xmm5
  b2:    c5 d8 <span class="integer">59</span> d3              vmulps %xmm3,%xmm4,%xmm2
  b6:    c5 d8 <span class="integer">59</span> e0              vmulps %xmm0,%xmm4,%xmm4
  ba:    c5 f0 <span class="float">5</span>e db              vdivps %xmm3,%xmm1,%xmm3
  be:    c5 e8 <span class="integer">58</span> ed              vaddps %xmm5,%xmm2,%xmm5
  c2:    c5 f0 <span class="float">5</span>e c0              vdivps %xmm0,%xmm1,%xmm0
  c6:    c5 e0 <span class="integer">5</span>c dc              vsubps %xmm4,%xmm3,%xmm3
  ca:    c5 e8 <span class="integer">58</span> d0              vaddps %xmm0,%xmm2,%xmm2
  ce:    c5 e8 <span class="integer">58</span> d3              vaddps %xmm3,%xmm2,%xmm2
  d2:    c5 e8 <span class="integer">59</span> d5              vmulps %xmm5,%xmm2,%xmm2
  d6:    c5 f8 <span class="integer">29</span> <span class="integer">14</span> <span class="integer">82</span>           vmovaps %xmm2,(%rdx,%rax,<span class="integer">4</span>)
  db:    <span class="integer">48</span> <span class="integer">83</span> c0 <span class="octal">04</span>              add    $<span class="hex">0x4</span>,%rax
  df:    <span class="integer">48</span> <span class="integer">39</span> c7                 cmp    %rax,%rdi
  e2:    <span class="integer">77</span> b4                    ja     <span class="integer">98</span> &lt;_ZN4simd11test_sse_eERKSt6vectorIfSaIfEES4_S4_S4_RS2_+<span class="hex">0x28</span>&gt;
  e4:    f3 c3                    repz retq

<span class="comment">// test_sse_e2</span>
  <span class="integer">70</span>:    <span class="integer">4</span>c <span class="integer">8</span>b <span class="float">0f</span>                 mov    (%rdi),%r9
  <span class="integer">73</span>:    <span class="integer">48</span> <span class="integer">8</span>b <span class="float">7f</span> <span class="integer">08</span>              mov    <span class="hex">0x8</span>(%rdi),%rdi
  <span class="integer">77</span>:    <span class="integer">4</span>c <span class="integer">29</span> cf                 sub    %r9,%rdi
  <span class="integer">7</span>a:    <span class="integer">48</span> c1 ff <span class="octal">02</span>              sar    $<span class="hex">0x2</span>,%rdi
  <span class="float">7</span>e:    <span class="integer">48</span> c1 ef <span class="octal">02</span>              shr    $<span class="hex">0x2</span>,%rdi
  <span class="integer">82</span>:    <span class="integer">48</span> <span class="integer">85</span> ff                 test   %rdi,%rdi
  <span class="integer">85</span>:    <span class="integer">74</span> <span class="integer">5</span>d                    je     e4 &lt;_ZN4simd11test_sse_e2ERKSt6vectorIfSaIfEES4_S4_S4_RS2_+<span class="hex">0x74</span>&gt;
  <span class="integer">87</span>:    <span class="integer">4</span>c <span class="integer">8</span>b <span class="integer">16</span>                 mov    (%rsi),%r10
  <span class="integer">8</span>a:    <span class="integer">31</span> c0                    <span class="keyword">xor</span>    %eax,%eax
  <span class="integer">8</span>c:    <span class="integer">48</span> <span class="integer">8</span>b <span class="integer">32</span>                 mov    (%rdx),%rsi
  <span class="float">8f</span>:    <span class="integer">48</span> <span class="integer">8</span>b <span class="integer">09</span>                 mov    (%rcx),%rcx
  <span class="integer">92</span>:    <span class="integer">49</span> <span class="integer">8</span>b <span class="integer">10</span>                 mov    (%r8),%rdx
  <span class="integer">95</span>:    <span class="float">0f</span> <span class="float">1f</span> <span class="octal">00</span>                 nopl   (%rax)
  <span class="integer">98</span>:    c5 f8 <span class="integer">28</span> <span class="integer">0</span>c <span class="integer">86</span>           vmovaps (%rsi,%rax,<span class="integer">4</span>),%xmm1
  <span class="integer">9</span>d:    c5 f8 <span class="integer">28</span> <span class="octal">04</span> <span class="integer">81</span>           vmovaps (%rcx,%rax,<span class="integer">4</span>),%xmm0
  a2:    c4 c1 <span class="integer">78</span> <span class="integer">28</span> <span class="integer">24</span> <span class="integer">81</span>        vmovaps (%r9,%rax,<span class="integer">4</span>),%xmm4
  a8:    c4 c1 <span class="integer">78</span> <span class="integer">28</span> <span class="integer">1</span>c <span class="integer">82</span>        vmovaps (%r10,%rax,<span class="integer">4</span>),%xmm3
  ae:    c5 f0 <span class="integer">59</span> e8              vmulps %xmm0,%xmm1,%xmm5
  b2:    c5 d8 <span class="integer">59</span> d3              vmulps %xmm3,%xmm4,%xmm2
  b6:    c5 d8 <span class="integer">59</span> e0              vmulps %xmm0,%xmm4,%xmm4
  ba:    c5 f0 <span class="float">5</span>e db              vdivps %xmm3,%xmm1,%xmm3
  be:    c5 e8 <span class="integer">58</span> ed              vaddps %xmm5,%xmm2,%xmm5
  c2:    c5 f0 <span class="float">5</span>e c0              vdivps %xmm0,%xmm1,%xmm0
  c6:    c5 e0 <span class="integer">5</span>c dc              vsubps %xmm4,%xmm3,%xmm3
  ca:    c5 e8 <span class="integer">58</span> d0              vaddps %xmm0,%xmm2,%xmm2
  ce:    c5 e8 <span class="integer">58</span> d3              vaddps %xmm3,%xmm2,%xmm2
  d2:    c5 e8 <span class="integer">59</span> d5              vmulps %xmm5,%xmm2,%xmm2
  d6:    c5 f8 <span class="integer">29</span> <span class="integer">14</span> <span class="integer">82</span>           vmovaps %xmm2,(%rdx,%rax,<span class="integer">4</span>)
  db:    <span class="integer">48</span> <span class="integer">83</span> c0 <span class="octal">04</span>              add    $<span class="hex">0x4</span>,%rax
  df:    <span class="integer">48</span> <span class="integer">39</span> c7                 cmp    %rax,%rdi
  e2:    <span class="integer">77</span> b4                    ja     <span class="integer">98</span> &lt;_ZN4simd11test_sse_e2ERKSt6vectorIfSaIfEES4_S4_S4_RS2_+<span class="hex">0x28</span>&gt;
  e4:    f3 c3                    repz retq 
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>To conclude, operators overloads don’t prevent the compiler to reorder instructions during optimization, and thus they don’t introduce any performance issue. Since they allow you to write code more readable and easier to maintain, it would be a shame not to use them.</p>

<h2 id="refactoring-the-wrappers-without-crtp">5. Refactoring the wrappers without CRTP</h2>

<p>Before we consider refactoring the wrappers, let’s see the overhead of the CRTP layer in a more realistic code. Using the <strong>test_sse_d</strong> and <strong>test_sse_e</strong> functions of the previous sectino with the first versino of the wrappers (the one with CRTP), here is the result of objdump:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>test_sse.asm </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
</pre></td>
  <td class="code"><pre>
<span class="comment">// test_sse_d</span>
  <span class="integer">70</span>:    c4 c1 <span class="integer">78</span> <span class="integer">28</span> <span class="octal">00</span>           vmovaps (%r8),%xmm0
  <span class="integer">75</span>:    <span class="integer">48</span> <span class="integer">89</span> f8                 mov    %rdi,%rax
  <span class="integer">78</span>:    c5 f8 <span class="integer">28</span> <span class="integer">09</span>              vmovaps (%rcx),%xmm1
  <span class="integer">7</span>c:    c5 f8 <span class="integer">28</span> <span class="integer">1</span>a              vmovaps (%rdx),%xmm3
  <span class="integer">80</span>:    c5 f8 <span class="integer">28</span> <span class="integer">26</span>              vmovaps (%rsi),%xmm4
  <span class="integer">84</span>:    c5 f0 <span class="integer">59</span> e8              vmulps %xmm0,%xmm1,%xmm5
  <span class="integer">88</span>:    c5 d8 <span class="integer">59</span> d3              vmulps %xmm3,%xmm4,%xmm2
  <span class="integer">8</span>c:    c5 d8 <span class="integer">59</span> e0              vmulps %xmm0,%xmm4,%xmm4
  <span class="integer">90</span>:    c5 f0 <span class="float">5</span>e c0              vdivps %xmm0,%xmm1,%xmm0
  <span class="integer">94</span>:    c5 e8 <span class="integer">58</span> ed              vaddps %xmm5,%xmm2,%xmm5
  <span class="integer">98</span>:    c5 f0 <span class="float">5</span>e db              vdivps %xmm3,%xmm1,%xmm3
  <span class="integer">9</span>c:    c5 e8 <span class="integer">58</span> d0              vaddps %xmm0,%xmm2,%xmm2
  a0:    c5 e8 <span class="integer">58</span> d3              vaddps %xmm3,%xmm2,%xmm2
  a4:    c5 e8 <span class="integer">5</span>c e4              vsubps %xmm4,%xmm2,%xmm4
  a8:    c5 d8 <span class="integer">59</span> e5              vmulps %xmm5,%xmm4,%xmm4
  ac:    c5 f8 <span class="integer">29</span> <span class="integer">27</span>              vmovaps %xmm4,(%rdi)
  b0:    c3                       retq   
  b1:    <span class="integer">66</span> <span class="integer">66</span> <span class="integer">66</span> <span class="integer">66</span> <span class="integer">66</span> <span class="integer">66</span> <span class="float">2</span>e     data32 data32 data32 data32 data32 nopw %cs:<span class="hex">0x0</span>(%rax,%rax,<span class="integer">1</span>)
  b8:    <span class="float">0f</span> <span class="float">1f</span> <span class="integer">84</span> <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span> <span class="octal">00</span> 
  bf:    <span class="octal">00</span> 

<span class="comment">// test_sse_e</span>
  c0:    <span class="integer">4</span>c <span class="integer">8</span>b <span class="float">0f</span>                 mov    (%rdi),%r9
  c3:    <span class="integer">48</span> <span class="integer">8</span>b <span class="float">7f</span> <span class="integer">08</span>              mov    <span class="hex">0x8</span>(%rdi),%rdi
  c7:    <span class="integer">4</span>c <span class="integer">29</span> cf                 sub    %r9,%rdi
  ca:    <span class="integer">48</span> c1 ff <span class="octal">02</span>              sar    $<span class="hex">0x2</span>,%rdi
  ce:    <span class="integer">48</span> c1 ef <span class="octal">02</span>              shr    $<span class="hex">0x2</span>,%rdi
  d2:    <span class="integer">48</span> <span class="integer">85</span> ff                 test   %rdi,%rdi
  d5:    <span class="integer">74</span> <span class="integer">5</span>d                    je     <span class="integer">134</span> &lt;_ZN4simd10test_sse_eERKSt6vectorIfSaIfEES4_S4_S4_RS2_+<span class="hex">0x74</span>&gt;
  d7:    <span class="integer">4</span>c <span class="integer">8</span>b <span class="integer">16</span>                 mov    (%rsi),%r10
  da:    <span class="integer">31</span> c0                    <span class="keyword">xor</span>    %eax,%eax
  dc:    <span class="integer">48</span> <span class="integer">8</span>b <span class="integer">32</span>                 mov    (%rdx),%rsi
  df:    <span class="integer">48</span> <span class="integer">8</span>b <span class="integer">09</span>                 mov    (%rcx),%rcx
  e2:    <span class="integer">49</span> <span class="integer">8</span>b <span class="integer">10</span>                 mov    (%r8),%rdx
  e5:    <span class="float">0f</span> <span class="float">1f</span> <span class="octal">00</span>                 nopl   (%rax)
  e8:    c5 f8 <span class="integer">28</span> <span class="integer">0</span>c <span class="integer">86</span>           vmovaps (%rsi,%rax,<span class="integer">4</span>),%xmm1
  ed:    c5 f8 <span class="integer">28</span> <span class="octal">04</span> <span class="integer">81</span>           vmovaps (%rcx,%rax,<span class="integer">4</span>),%xmm0
  f2:    c4 c1 <span class="integer">78</span> <span class="integer">28</span> <span class="integer">24</span> <span class="integer">81</span>        vmovaps (%r9,%rax,<span class="integer">4</span>),%xmm4
  f8:    c4 c1 <span class="integer">78</span> <span class="integer">28</span> <span class="integer">1</span>c <span class="integer">82</span>        vmovaps (%r10,%rax,<span class="integer">4</span>),%xmm3
  fe:    c5 f0 <span class="integer">59</span> e8              vmulps %xmm0,%xmm1,%xmm5
 <span class="integer">102</span>:    c5 d8 <span class="integer">59</span> d3              vmulps %xmm3,%xmm4,%xmm2
 <span class="integer">106</span>:    c5 d8 <span class="integer">59</span> e0              vmulps %xmm0,%xmm4,%xmm4
 <span class="integer">10</span>a:    c5 f0 <span class="float">5</span>e c0              vdivps %xmm0,%xmm1,%xmm0
 <span class="integer">1</span><span class="float">0</span>e:    c5 e8 <span class="integer">58</span> ed              vaddps %xmm5,%xmm2,%xmm5
 <span class="integer">112</span>:    c5 f0 <span class="float">5</span>e db              vdivps %xmm3,%xmm1,%xmm3
 <span class="integer">116</span>:    c5 e8 <span class="integer">58</span> d0              vaddps %xmm0,%xmm2,%xmm2
 <span class="integer">11</span>a:    c5 e8 <span class="integer">58</span> d3              vaddps %xmm3,%xmm2,%xmm2
 <span class="integer">1</span><span class="float">1</span>e:    c5 e8 <span class="integer">5</span>c e4              vsubps %xmm4,%xmm2,%xmm4
 <span class="integer">122</span>:    c5 d8 <span class="integer">59</span> e5              vmulps %xmm5,%xmm4,%xmm4
 <span class="integer">126</span>:    c5 f8 <span class="integer">29</span> <span class="integer">24</span> <span class="integer">82</span>           vmovaps %xmm4,(%rdx,%rax,<span class="integer">4</span>)
 <span class="integer">12</span>b:    <span class="integer">48</span> <span class="integer">83</span> c0 <span class="octal">04</span>              add    $<span class="hex">0x4</span>,%rax
 <span class="integer">1</span><span class="float">2f</span>:    <span class="integer">48</span> <span class="integer">39</span> c7                 cmp    %rax,%rdi
 <span class="integer">132</span>:    <span class="integer">77</span> b4                    ja     e8 &lt;_ZN4simd10test_sse_eERKSt6vectorIfSaIfEES4_S4_S4_RS2_+<span class="hex">0x28</span>&gt;
 <span class="integer">134</span>:    f3 c3                    repz retq 
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>In <strong>test_sse_d</strong>, we have six more instructions than in the previous version, these instructions are data transfer to the SIMD registers at the beginning of the function, and data transfer from the SIMD register at the end of the function. Now if we look at <strong>test_sse_e</strong>, we’ve got exactly the same code as in the previous section. The call to <strong>test_sse_d</strong> is inlined, and since the data transfer from and to SIMD registers is required by <strong>load_a</strong> and <strong>store_a</strong> functions, there is no need to keep the <strong>movaps</strong> instructions of <strong>test_sse_d</strong>. So if the functions working with wrappers are small enough to be inlined and if computation instructions are used between load and store functions, using the wrappers with CRTP should not introduce any overhead since the compiler will remove useless <strong>movaps</strong> instructions.</p>

<p>However, if you still want to refactor the wrappers but don’t want to repeat the boilerplate implementation of operators overloads, the alternative is to use preprocessor macros:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>simd_sse.hpp </span></figcaption>
 <table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
</pre></td>
  <td class="code"><pre>
<span class="preprocessor">#define</span> DEFINE_OPERATOR+=(RET_TYPE,ARG_TYPE)\
    <span class="directive">inline</span> RET_TYPE&amp; <span class="directive">operator</span>+=(<span class="directive">const</span> ARG_TYPE&amp; rhs)\
    {\
        *<span class="local-variable">this</span> = *<span class="local-variable">this</span> + rhs;\
        <span class="keyword">return</span> *<span class="local-variable">this</span>;\
    }
<span class="comment">// ... etc for other computed assignment operators</span>
<span class="preprocessor">#define</span> DEFINE_ASSIGNMENT_OPERATORS(TYPE,SCALAR_TYPE)\
    DEFINE_OPERATOR+=(TYPE,TYPE)\
    DEFINE_OPERATOR+=(TYPE,SCALAR_TYPE)\
    DEFINE_OPERATOR-=(TYPE,TYPE)\
    DEFINE_OPERATOR-=(TYPE,SCALAR_TYPE)\
    <span class="comment">// etc</span>
</pre></td>
</tr></table>
 </figure></notextile></div>

<p>This is much less elegant, but you are guaranteed there won’t be any performance issue.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Performance is not an intuitive domain; we have to check any assumption we make, because these assumptions can be legacy of time when compilers were inefficient or buggy, or a bias due to our misunderstood of some mechanisms of the language. Here we’ve seen that neither operator overloads nor constant reference argument instead of value argument introduce any performance issue with GCC, but this might be different with another compiler.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Johan Mabille</span></span>

      








  


<time datetime="2014-11-20T01:39:57+01:00" pubdate data-updated="true">Nov 20<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/codeproject/'>CodeProject</a>, <a class='category' href='/blog/categories/simd/'>SIMD</a>, <a class='category' href='/blog/categories/vectorization/'>Vectorization</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/10/25/writing-c-plus-plus-wrappers-for-simd-intrinsics-5/" title="Previous Post: Writing C++ Wrappers for SIMD Intrinsics (5)">&laquo; Writing C++ Wrappers for SIMD Intrinsics (5)</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/11/20/performance-considerations-aboud-simd-wrappers/">Performance Considerations Aboud SIMD Wrappers</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/25/writing-c-plus-plus-wrappers-for-simd-intrinsics-5/">Writing C++ Wrappers for SIMD Intrinsics (5)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/13/writing-c-plus-plus-wrappers-for-simd-intrinsics-4/">Writing C++ Wrappers for SIMD Intrinsics (4)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-3/">Writing C++ Wrappers for SIMD Intrinsics (3)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-2/">Writing C++ Wrappers for SIMD Intrinsics (2)</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/jmabille">@jmabille</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'jmabille',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Johan Mabille -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'thecplusplusscientist';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://jmabille.github.io/blog/2014/11/20/performance-considerations-aboud-simd-wrappers/';
        var disqus_url = 'http://jmabille.github.io/blog/2014/11/20/performance-considerations-aboud-simd-wrappers/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
